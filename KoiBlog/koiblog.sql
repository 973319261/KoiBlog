/*
SQLyog 企业版 - MySQL GUI v8.14 
MySQL - 5.5.53 : Database - koiblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`koiblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `koiblog`;

/*Table structure for table `article` */

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `article_title` varchar(100) NOT NULL,
  `article_mdContent` text NOT NULL,
  `article_htmlContent` text NOT NULL,
  `article_summary` text,
  `article_publishDate` datetime NOT NULL,
  `article_editTime` datetime NOT NULL,
  `article_state` int(11) DEFAULT NULL,
  `article_pageView` int(11) DEFAULT NULL,
  `article_likeNumber` int(11) DEFAULT NULL,
  `article_iscomment` int(11) DEFAULT NULL,
  `article_type` int(11) DEFAULT NULL,
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=95 DEFAULT CHARSET=utf8;

/*Data for the table `article` */

insert  into `article`(`article_id`,`category_id`,`user_id`,`article_title`,`article_mdContent`,`article_htmlContent`,`article_summary`,`article_publishDate`,`article_editTime`,`article_state`,`article_pageView`,`article_likeNumber`,`article_iscomment`,`article_type`) values (66,34,1,'axios的封装','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-02 11:53:10','2019-09-02 11:53:10',0,1,1,0,0),(67,23,1,'sad',' 在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？\n 在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：\n\n> jedis-2.7.2.jar\n> spring-data-redis-1.6.0.RELEASE.jar\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619105112178.png)\n\n要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。\n1.	创建一个属性文件redis.properties，配置redis的相关参数：\n```\n# Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n```\n\n2.	创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）\n```java\npackage com.gx.common.utils;\nimport java.lang.reflect.Method;\npublic class KeyGenerator implements org.springframework.cache.interceptor.KeyGenerator {\n    @Override\n    public Object generate(Object o, Method method, Object... params) {\n        //规定  本类名+方法名+参数名 为key\n        StringBuilder sb = new StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(\"-\");\n        sb.append(method.getName());\n        sb.append(\"-\");\n        for (Object param : params) {\n            sb.append(param.toString());\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n3.	创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：\n \n\n```java\npackage com.gx.common.utils;\n\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\n\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private volatile JedisConnectionFactory jedisConnectionFactory;\n    private volatile RedisTemplate<String, String> redisTemplate;\n    private volatile RedisCacheManager redisCacheManager;\n\n    public RedisCacheConfig() {\n        super();\n    }\n\n    /**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * @param jedisConnectionFactory\n     * @param redisTemplate\n     * @param redisCacheManager\n     */\n    public RedisCacheConfig(JedisConnectionFactory jedisConnectionFactory, RedisTemplate<String, String> redisTemplate,\n                            RedisCacheManager redisCacheManager) {\n        this.jedisConnectionFactory = jedisConnectionFactory;\n        this.redisTemplate = redisTemplate;\n        this.redisCacheManager = redisCacheManager;\n    }\n\n    public JedisConnectionFactory getJedisConnecionFactory() {\n        return jedisConnectionFactory;\n    }\n\n    public RedisTemplate<String, String> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public RedisCacheManager getRedisCacheManager() {\n        return redisCacheManager;\n    }\n\n\n}\n```\n\n4.	创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：\n \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:cache=\"http://www.springframework.org/schema/cache\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\">\n	<!--配置redis的参数 -->\n	<bean class=\"redis.clients.jedis.JedisPoolConfig\" id=\"poolConfig\">\n		<property name=\"maxIdle\" value=\"${redis.maxIdle}\" />\n		<property name=\"maxTotal\" value=\"${redis.maxActive}\" />\n		<property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" />\n		<property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />\n	</bean>\n	<!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 -->\n	<bean id=\"jedisConnectionFactory\"\n		class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n		<property name=\"hostName\" value=\"${redis.host}\" />\n		<property name=\"port\" value=\"${redis.port}\" />\n		<!--<property name=\"password\" value=\"${redis.password}\"/> -->\n		<property name=\"database\" value=\"${redis.dbIndex}\" />\n		<property name=\"poolConfig\" ref=\"poolConfig\" />\n	</bean>\n	<!--redis操作模版,使用该对象可以操作redis -->\n	<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n		<property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n		<property name=\"keySerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" />\n		</property>\n		<property name=\"valueSerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" />\n		</property>\n		<!--开启事务 -->\n		<property name=\"enableTransactionSupport\" value=\"true\" />\n	</bean>\n	<!-- 配置redis缓存管理器 -->\n	<bean id=\"redisCacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\">\n		<constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" />\n		<property name=\"defaultExpiration\" value=\"${redis.expiration}\" />\n	</bean>\n	<!-- 配置RedisCacheConfig -->\n	<bean id=\"redisCacheConfig\" class=\"com.gx.common.utils.RedisCacheConfig\">\n		<constructor-arg ref=\"jedisConnectionFactory\" />\n		<constructor-arg ref=\"redisTemplate\" />\n		<constructor-arg ref=\"redisCacheManager\" />\n	</bean>\n	<!-- 声明redis中的key重新命名对象 -->\n	<bean id=\"keyGenerator\" class=\"com.gx.common.utils.KeyGenerator\" />\n	<cache:annotation-driven cache-manager=\"redisCacheManager\"\n		key-generator=\"keyGenerator\" />\n</beans>\n```\n\n5.	在applicationContext.xml中加载redis配置信息：\n \n\n```xml\n    <!-- 读取相关属性文件 -->\n	<context:property-placeholder location=\"classpath:db.properties,classpath:redis.properties\" />\n	<!-- 加载相应xml配置文件 -->\n	<import resource=\"spring-redis.xml\"/>\n```\n到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。\n \n```java\npackage com.gx.core.service.impl;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\nimport com.gx.core.dao.UserDao;\nimport com.gx.core.po.User;\nimport com.gx.core.service.UserService;\n@Service\npublic class UserServiceImpl implements UserService{\n	@Autowired\n	private UserDao userdao;\n	@Cacheable(\"user\")//添加缓存\n	public List<User> findUserById(String code) {\n	    System.out.println(\"查询数据库\");\n		return userdao.findUserById(code);\n	}\n	@CacheEvict(cacheNames=\"user\",allEntries=true)//清空缓存\n	public int addUser(User user) {\n		return userdao.addUser(user);\n	}\n}\n\n```\n@Cacheable、@CachePut、@CacheEvict 注释介绍：\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空\n','<p>在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？<br />\n在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：<br />\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：</p>\n<blockquote>\n<p>jedis-2.7.2.jar<br />\nspring-data-redis-1.6.0.RELEASE.jar<br />\n<img src=\"https://img-blog.csdnimg.cn/20190619105112178.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。</p>\n<ol>\n<li>创建一个属性文件redis.properties，配置redis的相关参数：</li>\n</ol>\n<pre><code class=\"lang-\"># Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n</code></pre>\n<ol start=\"2\">\n<li>创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n<span class=\"hljs-keyword\">import</span> java.lang.reflect.Method;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">KeyGenerator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">springframework</span>.<span class=\"hljs-title\">cache</span>.<span class=\"hljs-title\">interceptor</span>.<span class=\"hljs-title\">KeyGenerator</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(Object o, Method method, Object... params)</span> </span>{\n        <span class=\"hljs-comment\">//规定  本类名+方法名+参数名 为key</span>\n        StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        sb.append(method.getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        <span class=\"hljs-keyword\">for</span> (Object param : params) {\n            sb.append(param.toString());\n        }\n        <span class=\"hljs-keyword\">return</span> sb.toString();\n    }\n}\n\n</code></div></pre>\n<ol start=\"3\">\n<li>创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.cache.RedisCacheManager;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedisCacheConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CachingConfigurerSupport</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> JedisConnectionFactory jedisConnectionFactory;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisTemplate&lt;String, String&gt; redisTemplate;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisCacheManager redisCacheManager;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * <span class=\"hljs-doctag\">@param</span> jedisConnectionFactory\n     * <span class=\"hljs-doctag\">@param</span> redisTemplate\n     * <span class=\"hljs-doctag\">@param</span> redisCacheManager\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">(JedisConnectionFactory jedisConnectionFactory, RedisTemplate&lt;String, String&gt; redisTemplate,\n                            RedisCacheManager redisCacheManager)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.jedisConnectionFactory = jedisConnectionFactory;\n        <span class=\"hljs-keyword\">this</span>.redisTemplate = redisTemplate;\n        <span class=\"hljs-keyword\">this</span>.redisCacheManager = redisCacheManager;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> JedisConnectionFactory <span class=\"hljs-title\">getJedisConnecionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> jedisConnectionFactory;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisTemplate&lt;String, String&gt; <span class=\"hljs-title\">getRedisTemplate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisTemplate;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisCacheManager <span class=\"hljs-title\">getRedisCacheManager</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisCacheManager;\n    }\n\n\n}\n</code></div></pre>\n<ol start=\"4\">\n<li>创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n	<span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"hljs-attr\">xmlns:context</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/context\"</span>\n	<span class=\"hljs-attr\">xmlns:cache</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/cache\"</span>\n	<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\"</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的参数 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"redis.clients.jedis.JedisPoolConfig\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"poolConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxIdle\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxIdle}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxTotal\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxActive}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxWaitMillis\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxWait}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"testOnBorrow\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.testOnBorrow}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hostName\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.host}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"port\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.port}\"</span> /&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--&lt;property name=\"password\" value=\"${redis.password}\"/&gt; --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"database\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.dbIndex}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"poolConfig\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"poolConfig\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--redis操作模版,使用该对象可以操作redis --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.core.StringRedisTemplate\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"connectionFactory\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"keySerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.StringRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"valueSerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--开启事务 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"enableTransactionSupport\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置redis缓存管理器 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.cache.RedisCacheManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"redisOperations\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"defaultExpiration\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.expiration}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置RedisCacheConfig --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheConfig\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.RedisCacheConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 声明redis中的key重新命名对象 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.KeyGenerator\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cache:annotation-driven</span> <span class=\"hljs-attr\">cache-manager</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span>\n		<span class=\"hljs-attr\">key-generator</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></div></pre>\n<ol start=\"5\">\n<li>在applicationContext.xml中加载redis配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">    <span class=\"hljs-comment\">&lt;!-- 读取相关属性文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:property-placeholder</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:db.properties,classpath:redis.properties\"</span> /&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 加载相应xml配置文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">import</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">\"spring-redis.xml\"</span>/&gt;</span>\n</code></div></pre>\n<p>到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：<br />\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.core.service.impl;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CacheEvict;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.Cacheable;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;\n<span class=\"hljs-keyword\">import</span> com.gx.core.dao.UserDao;\n<span class=\"hljs-keyword\">import</span> com.gx.core.po.User;\n<span class=\"hljs-keyword\">import</span> com.gx.core.service.UserService;\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span></span>{\n	<span class=\"hljs-meta\">@Autowired</span>\n	<span class=\"hljs-keyword\">private</span> UserDao userdao;\n	<span class=\"hljs-meta\">@Cacheable</span>(<span class=\"hljs-string\">\"user\"</span>)<span class=\"hljs-comment\">//添加缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;User&gt; <span class=\"hljs-title\">findUserById</span><span class=\"hljs-params\">(String code)</span> </span>{\n	    System.out.println(<span class=\"hljs-string\">\"查询数据库\"</span>);\n		<span class=\"hljs-keyword\">return</span> userdao.findUserById(code);\n	}\n	<span class=\"hljs-meta\">@CacheEvict</span>(cacheNames=<span class=\"hljs-string\">\"user\"</span>,allEntries=<span class=\"hljs-keyword\">true</span>)<span class=\"hljs-comment\">//清空缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">addUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n		<span class=\"hljs-keyword\">return</span> userdao.addUser(user);\n	}\n}\n\n</code></div></pre>\n<p>@Cacheable、@CachePut、@CacheEvict 注释介绍：<br />\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存<br />\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用<br />\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空</p>\n','在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方','2019-09-02 11:55:11','2019-09-02 11:55:11',0,1,0,0,0),(65,34,1,'Spring与Redis整合',' 在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？\n 在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：\n\n> jedis-2.7.2.jar\n> spring-data-redis-1.6.0.RELEASE.jar\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619105112178.png)\n\n要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。\n1.	创建一个属性文件redis.properties，配置redis的相关参数：\n```\n# Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n```\n\n2.	创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）\n```java\npackage com.gx.common.utils;\nimport java.lang.reflect.Method;\npublic class KeyGenerator implements org.springframework.cache.interceptor.KeyGenerator {\n    @Override\n    public Object generate(Object o, Method method, Object... params) {\n        //规定  本类名+方法名+参数名 为key\n        StringBuilder sb = new StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(\"-\");\n        sb.append(method.getName());\n        sb.append(\"-\");\n        for (Object param : params) {\n            sb.append(param.toString());\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n3.	创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：\n \n\n```java\npackage com.gx.common.utils;\n\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\n\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private volatile JedisConnectionFactory jedisConnectionFactory;\n    private volatile RedisTemplate<String, String> redisTemplate;\n    private volatile RedisCacheManager redisCacheManager;\n\n    public RedisCacheConfig() {\n        super();\n    }\n\n    /**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * @param jedisConnectionFactory\n     * @param redisTemplate\n     * @param redisCacheManager\n     */\n    public RedisCacheConfig(JedisConnectionFactory jedisConnectionFactory, RedisTemplate<String, String> redisTemplate,\n                            RedisCacheManager redisCacheManager) {\n        this.jedisConnectionFactory = jedisConnectionFactory;\n        this.redisTemplate = redisTemplate;\n        this.redisCacheManager = redisCacheManager;\n    }\n\n    public JedisConnectionFactory getJedisConnecionFactory() {\n        return jedisConnectionFactory;\n    }\n\n    public RedisTemplate<String, String> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public RedisCacheManager getRedisCacheManager() {\n        return redisCacheManager;\n    }\n\n\n}\n```\n\n4.	创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：\n \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:cache=\"http://www.springframework.org/schema/cache\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\">\n	<!--配置redis的参数 -->\n	<bean class=\"redis.clients.jedis.JedisPoolConfig\" id=\"poolConfig\">\n		<property name=\"maxIdle\" value=\"${redis.maxIdle}\" />\n		<property name=\"maxTotal\" value=\"${redis.maxActive}\" />\n		<property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" />\n		<property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />\n	</bean>\n	<!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 -->\n	<bean id=\"jedisConnectionFactory\"\n		class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n		<property name=\"hostName\" value=\"${redis.host}\" />\n		<property name=\"port\" value=\"${redis.port}\" />\n		<!--<property name=\"password\" value=\"${redis.password}\"/> -->\n		<property name=\"database\" value=\"${redis.dbIndex}\" />\n		<property name=\"poolConfig\" ref=\"poolConfig\" />\n	</bean>\n	<!--redis操作模版,使用该对象可以操作redis -->\n	<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n		<property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n		<property name=\"keySerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" />\n		</property>\n		<property name=\"valueSerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" />\n		</property>\n		<!--开启事务 -->\n		<property name=\"enableTransactionSupport\" value=\"true\" />\n	</bean>\n	<!-- 配置redis缓存管理器 -->\n	<bean id=\"redisCacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\">\n		<constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" />\n		<property name=\"defaultExpiration\" value=\"${redis.expiration}\" />\n	</bean>\n	<!-- 配置RedisCacheConfig -->\n	<bean id=\"redisCacheConfig\" class=\"com.gx.common.utils.RedisCacheConfig\">\n		<constructor-arg ref=\"jedisConnectionFactory\" />\n		<constructor-arg ref=\"redisTemplate\" />\n		<constructor-arg ref=\"redisCacheManager\" />\n	</bean>\n	<!-- 声明redis中的key重新命名对象 -->\n	<bean id=\"keyGenerator\" class=\"com.gx.common.utils.KeyGenerator\" />\n	<cache:annotation-driven cache-manager=\"redisCacheManager\"\n		key-generator=\"keyGenerator\" />\n</beans>\n```\n\n5.	在applicationContext.xml中加载redis配置信息：\n \n\n```xml\n    <!-- 读取相关属性文件 -->\n	<context:property-placeholder location=\"classpath:db.properties,classpath:redis.properties\" />\n	<!-- 加载相应xml配置文件 -->\n	<import resource=\"spring-redis.xml\"/>\n```\n到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。\n \n```java\npackage com.gx.core.service.impl;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\nimport com.gx.core.dao.UserDao;\nimport com.gx.core.po.User;\nimport com.gx.core.service.UserService;\n@Service\npublic class UserServiceImpl implements UserService{\n	@Autowired\n	private UserDao userdao;\n	@Cacheable(\"user\")//添加缓存\n	public List<User> findUserById(String code) {\n	    System.out.println(\"查询数据库\");\n		return userdao.findUserById(code);\n	}\n	@CacheEvict(cacheNames=\"user\",allEntries=true)//清空缓存\n	public int addUser(User user) {\n		return userdao.addUser(user);\n	}\n}\n\n```\n@Cacheable、@CachePut、@CacheEvict 注释介绍：\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空\n','<p>在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？<br />\n在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：<br />\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：</p>\n<blockquote>\n<p>jedis-2.7.2.jar<br />\nspring-data-redis-1.6.0.RELEASE.jar<br />\n<img src=\"https://img-blog.csdnimg.cn/20190619105112178.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。</p>\n<ol>\n<li>创建一个属性文件redis.properties，配置redis的相关参数：</li>\n</ol>\n<pre><code class=\"lang-\"># Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n</code></pre>\n<ol start=\"2\">\n<li>创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n<span class=\"hljs-keyword\">import</span> java.lang.reflect.Method;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">KeyGenerator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">springframework</span>.<span class=\"hljs-title\">cache</span>.<span class=\"hljs-title\">interceptor</span>.<span class=\"hljs-title\">KeyGenerator</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(Object o, Method method, Object... params)</span> </span>{\n        <span class=\"hljs-comment\">//规定  本类名+方法名+参数名 为key</span>\n        StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        sb.append(method.getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        <span class=\"hljs-keyword\">for</span> (Object param : params) {\n            sb.append(param.toString());\n        }\n        <span class=\"hljs-keyword\">return</span> sb.toString();\n    }\n}\n\n</code></div></pre>\n<ol start=\"3\">\n<li>创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.cache.RedisCacheManager;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedisCacheConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CachingConfigurerSupport</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> JedisConnectionFactory jedisConnectionFactory;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisTemplate&lt;String, String&gt; redisTemplate;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisCacheManager redisCacheManager;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * <span class=\"hljs-doctag\">@param</span> jedisConnectionFactory\n     * <span class=\"hljs-doctag\">@param</span> redisTemplate\n     * <span class=\"hljs-doctag\">@param</span> redisCacheManager\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">(JedisConnectionFactory jedisConnectionFactory, RedisTemplate&lt;String, String&gt; redisTemplate,\n                            RedisCacheManager redisCacheManager)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.jedisConnectionFactory = jedisConnectionFactory;\n        <span class=\"hljs-keyword\">this</span>.redisTemplate = redisTemplate;\n        <span class=\"hljs-keyword\">this</span>.redisCacheManager = redisCacheManager;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> JedisConnectionFactory <span class=\"hljs-title\">getJedisConnecionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> jedisConnectionFactory;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisTemplate&lt;String, String&gt; <span class=\"hljs-title\">getRedisTemplate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisTemplate;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisCacheManager <span class=\"hljs-title\">getRedisCacheManager</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisCacheManager;\n    }\n\n\n}\n</code></div></pre>\n<ol start=\"4\">\n<li>创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n	<span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"hljs-attr\">xmlns:context</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/context\"</span>\n	<span class=\"hljs-attr\">xmlns:cache</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/cache\"</span>\n	<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\"</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的参数 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"redis.clients.jedis.JedisPoolConfig\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"poolConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxIdle\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxIdle}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxTotal\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxActive}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxWaitMillis\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxWait}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"testOnBorrow\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.testOnBorrow}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hostName\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.host}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"port\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.port}\"</span> /&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--&lt;property name=\"password\" value=\"${redis.password}\"/&gt; --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"database\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.dbIndex}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"poolConfig\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"poolConfig\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--redis操作模版,使用该对象可以操作redis --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.core.StringRedisTemplate\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"connectionFactory\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"keySerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.StringRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"valueSerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--开启事务 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"enableTransactionSupport\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置redis缓存管理器 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.cache.RedisCacheManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"redisOperations\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"defaultExpiration\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.expiration}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置RedisCacheConfig --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheConfig\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.RedisCacheConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 声明redis中的key重新命名对象 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.KeyGenerator\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cache:annotation-driven</span> <span class=\"hljs-attr\">cache-manager</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span>\n		<span class=\"hljs-attr\">key-generator</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></div></pre>\n<ol start=\"5\">\n<li>在applicationContext.xml中加载redis配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">    <span class=\"hljs-comment\">&lt;!-- 读取相关属性文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:property-placeholder</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:db.properties,classpath:redis.properties\"</span> /&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 加载相应xml配置文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">import</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">\"spring-redis.xml\"</span>/&gt;</span>\n</code></div></pre>\n<p>到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：<br />\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.core.service.impl;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CacheEvict;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.Cacheable;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;\n<span class=\"hljs-keyword\">import</span> com.gx.core.dao.UserDao;\n<span class=\"hljs-keyword\">import</span> com.gx.core.po.User;\n<span class=\"hljs-keyword\">import</span> com.gx.core.service.UserService;\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span></span>{\n	<span class=\"hljs-meta\">@Autowired</span>\n	<span class=\"hljs-keyword\">private</span> UserDao userdao;\n	<span class=\"hljs-meta\">@Cacheable</span>(<span class=\"hljs-string\">\"user\"</span>)<span class=\"hljs-comment\">//添加缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;User&gt; <span class=\"hljs-title\">findUserById</span><span class=\"hljs-params\">(String code)</span> </span>{\n	    System.out.println(<span class=\"hljs-string\">\"查询数据库\"</span>);\n		<span class=\"hljs-keyword\">return</span> userdao.findUserById(code);\n	}\n	<span class=\"hljs-meta\">@CacheEvict</span>(cacheNames=<span class=\"hljs-string\">\"user\"</span>,allEntries=<span class=\"hljs-keyword\">true</span>)<span class=\"hljs-comment\">//清空缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">addUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n		<span class=\"hljs-keyword\">return</span> userdao.addUser(user);\n	}\n}\n\n</code></div></pre>\n<p>@Cacheable、@CachePut、@CacheEvict 注释介绍：<br />\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存<br />\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用<br />\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空</p>\n','在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方','2019-09-02 10:49:57','2019-09-02 10:49:57',0,2,2,0,0),(63,38,1,'不落因果与不昧因果','今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。\n\n以下内容来自：腾讯儒释道\n\n \n\n百丈怀海禅师是禅宗一个非常有代表性的重要人物。著名的《百丈清规》便是由他制定的。据《五灯会元》记载：百丈禅师有一天上堂，下座后，众僧都已散去，独有一老人站着不走。百丈禅师便问其原因。老人回答说：“我不是人，实是野狐，迦叶佛时曾是这里的住持，当时有学人问我：‘大修行人还落因果否？’我回答说：‘不落因果。’\n\n \n\n因此便堕野狐身五百世，无法脱身，因仰慕禅师的修为，特请禅师慈悲开示。”百丈禅师默许了。于是老人合掌问道：“请问禅师，大修行人还落因果否？”百丈禅师答道：“不昧因果。”老人言下大悟，即礼谢道：“今承和尚代语，令我超脱狐身，乞和尚以亡僧礼送。”便消失了。次日，禅师在后山岩洞中发现一狐身，便用往生之礼葬了。\n\n \n\n大家试想想，这个狐狸就是一种示现，说明了它在迦叶佛的时候，因为说错了“不落因果”一句话，后来反复思量：不是啊！因为佛说万法皆空，因果不空，自己是不是说错了呢？就这一念的疑虑，便堕落狐狸身。其实，“不落因果”和“不昧因果”，到底有什么差别呢？这中间的一丝差别，就只是“迷”与“悟”；其实悟了以后，就无所谓因果不因果，但如果说“不昧因果”的话；“不昧”就是“不弃”，即是由于知道因果、明白因果，而把因果避开了。如何“避”呢？\n\n \n\n我们经常说：“菩萨畏因，众生畏果。”我们众生由于愚痴的关系，果报未现前时是不知道怕的，但当果报现前的时候，却又后悔莫及了。菩萨因为有智慧，所以不种因；不种因将来就无所谓“不落因果”与“不昧因果”的问题。我们今天既然知道了贪、瞋、痴的害处，便应该把它改掉；贪、瞋、痴三毒袪除了，将来就不必畏因果、落因果了。因此，如果我们所作所为，都是好的善因，对于修行来说，将会是很大的帮助。所以，佛陀教导我们不要执着于名相、文字，因为这些都是戏论，是全无意义的，我们应该以信、愿、行、证的方法来学佛。','<p>今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。</p>\n<p>以下内容来自：腾讯儒释道</p>\n<p>百丈怀海禅师是禅宗一个非常有代表性的重要人物。著名的《百丈清规》便是由他制定的。据《五灯会元》记载：百丈禅师有一天上堂，下座后，众僧都已散去，独有一老人站着不走。百丈禅师便问其原因。老人回答说：“我不是人，实是野狐，迦叶佛时曾是这里的住持，当时有学人问我：‘大修行人还落因果否？’我回答说：‘不落因果。’</p>\n<p>因此便堕野狐身五百世，无法脱身，因仰慕禅师的修为，特请禅师慈悲开示。”百丈禅师默许了。于是老人合掌问道：“请问禅师，大修行人还落因果否？”百丈禅师答道：“不昧因果。”老人言下大悟，即礼谢道：“今承和尚代语，令我超脱狐身，乞和尚以亡僧礼送。”便消失了。次日，禅师在后山岩洞中发现一狐身，便用往生之礼葬了。</p>\n<p>大家试想想，这个狐狸就是一种示现，说明了它在迦叶佛的时候，因为说错了“不落因果”一句话，后来反复思量：不是啊！因为佛说万法皆空，因果不空，自己是不是说错了呢？就这一念的疑虑，便堕落狐狸身。其实，“不落因果”和“不昧因果”，到底有什么差别呢？这中间的一丝差别，就只是“迷”与“悟”；其实悟了以后，就无所谓因果不因果，但如果说“不昧因果”的话；“不昧”就是“不弃”，即是由于知道因果、明白因果，而把因果避开了。如何“避”呢？</p>\n<p>我们经常说：“菩萨畏因，众生畏果。”我们众生由于愚痴的关系，果报未现前时是不知道怕的，但当果报现前的时候，却又后悔莫及了。菩萨因为有智慧，所以不种因；不种因将来就无所谓“不落因果”与“不昧因果”的问题。我们今天既然知道了贪、瞋、痴的害处，便应该把它改掉；贪、瞋、痴三毒袪除了，将来就不必畏因果、落因果了。因此，如果我们所作所为，都是好的善因，对于修行来说，将会是很大的帮助。所以，佛陀教导我们不要执着于名相、文字，因为这些都是戏论，是全无意义的，我们应该以信、愿、行、证的方法来学佛。</p>\n','今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。\n以下内容来自：腾讯儒释道\n百丈怀','2019-09-02 11:53:33','2019-09-02 11:53:33',0,10589,5,0,0),(64,23,1,'今天早晨听易中天说禅','今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。\n\n以下内容来自：腾讯儒释道\n\n \n\n百丈怀海禅师是禅宗一个非常有代表性的重要人物。著名的《百丈清规》便是由他制定的。据《五灯会元》记载：百丈禅师有一天上堂，下座后，众僧都已散去，独有一老人站着不走。百丈禅师便问其原因。老人回答说：“我不是人，实是野狐，迦叶佛时曾是这里的住持，当时有学人问我：‘大修行人还落因果否？’我回答说：‘不落因果。’\n\n \n\n因此便堕野狐身五百世，无法脱身，因仰慕禅师的修为，特请禅师慈悲开示。”百丈禅师默许了。于是老人合掌问道：“请问禅师，大修行人还落因果否？”百丈禅师答道：“不昧因果。”老人言下大悟，即礼谢道：“今承和尚代语，令我超脱狐身，乞和尚以亡僧礼送。”便消失了。次日，禅师在后山岩洞中发现一狐身，便用往生之礼葬了。\n\n \n\n大家试想想，这个狐狸就是一种示现，说明了它在迦叶佛的时候，因为说错了“不落因果”一句话，后来反复思量：不是啊！因为佛说万法皆空，因果不空，自己是不是说错了呢？就这一念的疑虑，便堕落狐狸身。其实，“不落因果”和“不昧因果”，到底有什么差别呢？这中间的一丝差别，就只是“迷”与“悟”；其实悟了以后，就无所谓因果不因果，但如果说“不昧因果”的话；“不昧”就是“不弃”，即是由于知道因果、明白因果，而把因果避开了。如何“避”呢？\n\n \n\n我们经常说：“菩萨畏因，众生畏果。”我们众生由于愚痴的关系，果报未现前时是不知道怕的，但当果报现前的时候，却又后悔莫及了。菩萨因为有智慧，所以不种因；不种因将来就无所谓“不落因果”与“不昧因果”的问题。我们今天既然知道了贪、瞋、痴的害处，便应该把它改掉；贪、瞋、痴三毒袪除了，将来就不必畏因果、落因果了。因此，如果我们所作所为，都是好的善因，对于修行来说，将会是很大的帮助。所以，佛陀教导我们不要执着于名相、文字，因为这些都是戏论，是全无意义的，我们应该以信、愿、行、证的方法来学佛。','<p>今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。</p>\n<p>以下内容来自：腾讯儒释道</p>\n<p>百丈怀海禅师是禅宗一个非常有代表性的重要人物。著名的《百丈清规》便是由他制定的。据《五灯会元》记载：百丈禅师有一天上堂，下座后，众僧都已散去，独有一老人站着不走。百丈禅师便问其原因。老人回答说：“我不是人，实是野狐，迦叶佛时曾是这里的住持，当时有学人问我：‘大修行人还落因果否？’我回答说：‘不落因果。’</p>\n<p>因此便堕野狐身五百世，无法脱身，因仰慕禅师的修为，特请禅师慈悲开示。”百丈禅师默许了。于是老人合掌问道：“请问禅师，大修行人还落因果否？”百丈禅师答道：“不昧因果。”老人言下大悟，即礼谢道：“今承和尚代语，令我超脱狐身，乞和尚以亡僧礼送。”便消失了。次日，禅师在后山岩洞中发现一狐身，便用往生之礼葬了。</p>\n<p>大家试想想，这个狐狸就是一种示现，说明了它在迦叶佛的时候，因为说错了“不落因果”一句话，后来反复思量：不是啊！因为佛说万法皆空，因果不空，自己是不是说错了呢？就这一念的疑虑，便堕落狐狸身。其实，“不落因果”和“不昧因果”，到底有什么差别呢？这中间的一丝差别，就只是“迷”与“悟”；其实悟了以后，就无所谓因果不因果，但如果说“不昧因果”的话；“不昧”就是“不弃”，即是由于知道因果、明白因果，而把因果避开了。如何“避”呢？</p>\n<p>我们经常说：“菩萨畏因，众生畏果。”我们众生由于愚痴的关系，果报未现前时是不知道怕的，但当果报现前的时候，却又后悔莫及了。菩萨因为有智慧，所以不种因；不种因将来就无所谓“不落因果”与“不昧因果”的问题。我们今天既然知道了贪、瞋、痴的害处，便应该把它改掉；贪、瞋、痴三毒袪除了，将来就不必畏因果、落因果了。因此，如果我们所作所为，都是好的善因，对于修行来说，将会是很大的帮助。所以，佛陀教导我们不要执着于名相、文字，因为这些都是戏论，是全无意义的，我们应该以信、愿、行、证的方法来学佛。</p>\n','今天早晨听易中天说禅，讲了一个富有禅意的故事，始终难忘，故分享之。\n以下内容来自：腾讯儒释道\n百丈怀','2019-09-02 11:53:25','2019-09-02 11:53:25',0,205,12,0,0),(60,1,1,'开发环境从从旧电脑转移到新电脑开发环境从从旧电脑转移到新电脑','上一次买的电脑还是17年暑假，那时候买的是 17款 8GB内存 128GB容量，用了两年，渐渐发现容量严重不足，内存也吃紧。\n\n就在前几天，痛下血本付全款(1.4w)买了最新款，MBP 13寸 19款 16GB内存 512GB容量 带 touchbar的那款。这是新旧两台合影，左边是17款的，右边是19款的。因为19款有根据周围光线自适应屏幕亮度，所以右边显得比较温和，左边是白光比较亮一点。\n\n目前新款还没有使用IDEA启动微服务项目，所以体验和旧款差不多，唯一不同就是多一个 touchbar，有点鸡肋，甚至不舒服，通常我们按 ESC 键都是实体按键，现在是点击触摸板，没有键盘那种的感觉。\n\n开发环境从从旧电脑转移到新电脑\n\n \n\n1.安装软件\n电脑是昨天晚上拿的快递，然后就是一顿装软件，如 QQ、微信、百度网盘、迅雷、印象笔记、Chrome、iterm2、IDEA、WebStorm、Parallels Desktop、Navicat、Office2016、千牛、网易云音乐、Dr.Cleaner、PostMan、rdm 等常用软件，还有 homebrew、java、redis、mysql、git、npm、node 等开发常用软件。\n\n \n\n2. 同步项目代码和第三方工具\n因为旧的电脑有很多之前写的项目(workspace)、Maven、ElasticSearch、Tomcat、RocketMQ、zookeeper 等可携带的代码和工具，这些可以直接拿个U盘或者移动硬盘进行拷贝，大概10GB左右。为了让两台电脑几乎一致，在电脑激活的时候设置机器名都是跟之前的一样。然后这里拷贝文件，也是拷贝到同一物理路径。\n\n \n\n3.同步 IDEA 配置信息和项目列表\nIDEA 配置可以在旧电脑里，通过点击 File ->Export Settings 导出，然后通过移动硬盘将 settings.zip 传到新电脑上，在 IDEA 里点击 File ->Import Settings 即可；\n\nIDEA 的项目信息，如 IDEA 启动后最近项目列表的数据信息在 ~/Library/Preferences 里，可以将该项目从旧电脑里覆盖过来就行。然后 IDEA 打开后就有最近项目列表了\n\n \n\n4.同步数据库\n之前电脑里的数据库文件是在 /usr/local/mysql/data 目录，直接拷贝该目录\n\n新的电脑 MySQL 用的是 Homebrew 安装的 MySQL, 数据库文件目录在 /usr/local/var/mysql 目录，\n\n即将原来的 /usr/local/mysql/data 里的数据全部复制，粘贴到新的 /usr/local/var/mysql/ 里去\n\n然后重启新电脑MySQL，使用Navicat连接数据库，可以看到所有的数据库，数据都在\n\n \n\n \n\n关于文件转移有大概几种方法：\n\n上传到 iCloud、百度网盘或Dropbox\n通过U盘或移动硬盘拷贝\n两台电脑同一网络下，旧电脑设置共享文件夹，新电脑通过局域网拷贝','<p>上一次买的电脑还是17年暑假，那时候买的是 17款 8GB内存 128GB容量，用了两年，渐渐发现容量严重不足，内存也吃紧。</p>\n<p>就在前几天，痛下血本付全款(1.4w)买了最新款，MBP 13寸 19款 16GB内存 512GB容量 带 touchbar的那款。这是新旧两台合影，左边是17款的，右边是19款的。因为19款有根据周围光线自适应屏幕亮度，所以右边显得比较温和，左边是白光比较亮一点。</p>\n<p>目前新款还没有使用IDEA启动微服务项目，所以体验和旧款差不多，唯一不同就是多一个 touchbar，有点鸡肋，甚至不舒服，通常我们按 ESC 键都是实体按键，现在是点击触摸板，没有键盘那种的感觉。</p>\n<p>开发环境从从旧电脑转移到新电脑</p>\n<p>1.安装软件<br />\n电脑是昨天晚上拿的快递，然后就是一顿装软件，如 QQ、微信、百度网盘、迅雷、印象笔记、Chrome、iterm2、IDEA、WebStorm、Parallels Desktop、Navicat、Office2016、千牛、网易云音乐、Dr.Cleaner、PostMan、rdm 等常用软件，还有 homebrew、java、redis、mysql、git、npm、node 等开发常用软件。</p>\n<ol start=\"2\">\n<li>同步项目代码和第三方工具<br />\n因为旧的电脑有很多之前写的项目(workspace)、Maven、ElasticSearch、Tomcat、RocketMQ、zookeeper 等可携带的代码和工具，这些可以直接拿个U盘或者移动硬盘进行拷贝，大概10GB左右。为了让两台电脑几乎一致，在电脑激活的时候设置机器名都是跟之前的一样。然后这里拷贝文件，也是拷贝到同一物理路径。</li>\n</ol>\n<p>3.同步 IDEA 配置信息和项目列表<br />\nIDEA 配置可以在旧电脑里，通过点击 File -&gt;Export Settings 导出，然后通过移动硬盘将 settings.zip 传到新电脑上，在 IDEA 里点击 File -&gt;Import Settings 即可；</p>\n<p>IDEA 的项目信息，如 IDEA 启动后最近项目列表的数据信息在 ~/Library/Preferences 里，可以将该项目从旧电脑里覆盖过来就行。然后 IDEA 打开后就有最近项目列表了</p>\n<p>4.同步数据库<br />\n之前电脑里的数据库文件是在 /usr/local/mysql/data 目录，直接拷贝该目录</p>\n<p>新的电脑 MySQL 用的是 Homebrew 安装的 MySQL, 数据库文件目录在 /usr/local/var/mysql 目录，</p>\n<p>即将原来的 /usr/local/mysql/data 里的数据全部复制，粘贴到新的 /usr/local/var/mysql/ 里去</p>\n<p>然后重启新电脑MySQL，使用Navicat连接数据库，可以看到所有的数据库，数据都在</p>\n<p>关于文件转移有大概几种方法：</p>\n<p>上传到 iCloud、百度网盘或Dropbox<br />\n通过U盘或移动硬盘拷贝<br />\n两台电脑同一网络下，旧电脑设置共享文件夹，新电脑通过局域网拷贝</p>\n','上一次买的电脑还是17年暑假，那时候买的是 17款 8GB内存 128GB容量，用了两年，渐渐发现容','2019-08-30 10:16:40','2019-08-20 01:45:40',0,554,1,0,0),(61,1,1,'Java 之 BASE64 加密解密','背景\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样\n\nhttp://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92d53cd953&account=saysky\n\n验证原理就是，当用户点击链接，然后请求 控制器里的 resetpass 方法，获得 sid(密钥) 和 account(用户名) 两个参数。根据用户名去数据库中的 “邮件找回密码” 表(mail_retrieve)里寻找记录，获得 mailRetrieve 对象，然后比较 参数中的 sid 和 mailRetrieve.getSid() 即可，当然也可以加一个outtimes 超时时间 字段。\n\n如上链接，sid 是经过 MD5 加密，并且无需解密，只需要比较参数dis和数据库sid是否相等，而account 用户名一定要传过去，目前是直接明文显示，感觉不是特别好，所以这里需要给 accout 也加密一下比较好。然后在 控制器里接受参数的时候，然后在解密即可。\n\n目标是，无需太复杂，肉眼无法识别即可，但求效率高。\n\n \n\nBASE64 加密解码\n代码如下\n```java\npackage com.liuyanzhao.chuyun.util;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\nimport java.io.UnsupportedEncodingException;\n/**\n * @author 言曌\n * @date 2018/2/24 上午11:45\n */\npublic class Base64Util {\n    /**\n     * 加密\n     * @param str\n     * @return\n     */\n    @SuppressWarnings(\"restriction\")\n    public static String encode(String str) {\n        byte[] b = null;\n        String s = null;\n        try {\n            b = str.getBytes(\"utf-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        if (b != null) {\n            s = new BASE64Encoder().encode(b);\n        }\n        return s;\n    }\n    /**\n     * 解密\n     * @param s\n     * @return\n     */\n    @SuppressWarnings(\"restriction\")\n    public static String decode(String s) {\n        byte[] b = null;\n        String result = null;\n        if (s != null) {\n            BASE64Decoder decoder = new BASE64Decoder();\n            try {\n                b = decoder.decodeBuffer(s);\n                result = new String(b, \"utf-8\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }\n    public static void main(String args[]) {\n        Long startTime = System.currentTimeMillis();\n        String rawString = \"loveluoqi\";\n        String encodedString = encode(rawString);\n        String decodedString = decode(encodedString);\n        System.out.println(rawString);\n        System.out.println(encodedString);\n        System.out.println(decodedString);\n        Long endTime = System.currentTimeMillis();\n        System.out.println(\"总共耗时毫秒数：\" + (endTime - startTime));\n    }\n}\n```\n','<p>背景<br />\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样</p>\n<p>http://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92d53cd953&amp;account=saysky</p>\n<p>验证原理就是，当用户点击链接，然后请求 控制器里的 resetpass 方法，获得 sid(密钥) 和 account(用户名) 两个参数。根据用户名去数据库中的 “邮件找回密码” 表(mail_retrieve)里寻找记录，获得 mailRetrieve 对象，然后比较 参数中的 sid 和 mailRetrieve.getSid() 即可，当然也可以加一个outtimes 超时时间 字段。</p>\n<p>如上链接，sid 是经过 MD5 加密，并且无需解密，只需要比较参数dis和数据库sid是否相等，而account 用户名一定要传过去，目前是直接明文显示，感觉不是特别好，所以这里需要给 accout 也加密一下比较好。然后在 控制器里接受参数的时候，然后在解密即可。</p>\n<p>目标是，无需太复杂，肉眼无法识别即可，但求效率高。</p>\n<p>BASE64 加密解码<br />\n代码如下</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.liuyanzhao.chuyun.util;\n<span class=\"hljs-keyword\">import</span> sun.misc.BASE64Decoder;\n<span class=\"hljs-keyword\">import</span> sun.misc.BASE64Encoder;\n<span class=\"hljs-keyword\">import</span> java.io.UnsupportedEncodingException;\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> 言曌\n * <span class=\"hljs-doctag\">@date</span> 2018/2/24 上午11:45\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Base64Util</span> </span>{\n    <span class=\"hljs-comment\">/**\n     * 加密\n     * <span class=\"hljs-doctag\">@param</span> str\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"restriction\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(String str)</span> </span>{\n        <span class=\"hljs-keyword\">byte</span>[] b = <span class=\"hljs-keyword\">null</span>;\n        String s = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            b = str.getBytes(<span class=\"hljs-string\">\"utf-8\"</span>);\n        } <span class=\"hljs-keyword\">catch</span> (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        <span class=\"hljs-keyword\">if</span> (b != <span class=\"hljs-keyword\">null</span>) {\n            s = <span class=\"hljs-keyword\">new</span> BASE64Encoder().encode(b);\n        }\n        <span class=\"hljs-keyword\">return</span> s;\n    }\n    <span class=\"hljs-comment\">/**\n     * 解密\n     * <span class=\"hljs-doctag\">@param</span> s\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"restriction\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String s)</span> </span>{\n        <span class=\"hljs-keyword\">byte</span>[] b = <span class=\"hljs-keyword\">null</span>;\n        String result = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span> (s != <span class=\"hljs-keyword\">null</span>) {\n            BASE64Decoder decoder = <span class=\"hljs-keyword\">new</span> BASE64Decoder();\n            <span class=\"hljs-keyword\">try</span> {\n                b = decoder.decodeBuffer(s);\n                result = <span class=\"hljs-keyword\">new</span> String(b, <span class=\"hljs-string\">\"utf-8\"</span>);\n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String args[])</span> </span>{\n        Long startTime = System.currentTimeMillis();\n        String rawString = <span class=\"hljs-string\">\"loveluoqi\"</span>;\n        String encodedString = encode(rawString);\n        String decodedString = decode(encodedString);\n        System.out.println(rawString);\n        System.out.println(encodedString);\n        System.out.println(decodedString);\n        Long endTime = System.currentTimeMillis();\n        System.out.println(<span class=\"hljs-string\">\"总共耗时毫秒数：\"</span> + (endTime - startTime));\n    }\n}\n</code></div></pre>\n','背景\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样\nhttp://localhost','2019-08-20 00:39:11','2019-08-20 00:39:11',0,226,2,0,0),(62,1,1,'密码','背景\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样\n\nhttp://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92d53cd953&account=saysky\n\n验证原理就是，当用户点击链接，然后请求 控制器里的 resetpass 方法，获得 sid(密钥) 和 account(用户名) 两个参数。根据用户名去数据库中的 “邮件找回密码” 表(mail_retrieve)里寻找记录，获得 mailRetrieve 对象，然后比较 参数中的 sid 和 mailRetrieve.getSid() 即可，当然也可以加一个outtimes 超时时间 字段。\n\n如上链接，sid 是经过 MD5 加密，并且无需解密，只需要比较参数dis和数据库sid是否相等，而account 用户名一定要传过去，目前是直接明文显示，感觉不是特别好，所以这里需要给 accout 也加密一下比较好。然后在 控制器里接受参数的时候，然后在解密即可。\n\n目标是，无需太复杂，肉眼无法识别即可，但求效率高。\n\n \n\nBASE64 加密解码\n代码如下\n```java\npackage com.liuyanzhao.chuyun.util;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\nimport java.io.UnsupportedEncodingException;\n/**\n * @author 言曌\n * @date 2018/2/24 上午11:45\n */\npublic class Base64Util {\n    /**\n     * 加密\n     * @param str\n     * @return\n     */\n    @SuppressWarnings(\"restriction\")\n    public static String encode(String str) {\n        byte[] b = null;\n        String s = null;\n        try {\n            b = str.getBytes(\"utf-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        if (b != null) {\n            s = new BASE64Encoder().encode(b);\n        }\n        return s;\n    }\n    /**\n     * 解密\n     * @param s\n     * @return\n     */\n    @SuppressWarnings(\"restriction\")\n    public static String decode(String s) {\n        byte[] b = null;\n        String result = null;\n        if (s != null) {\n            BASE64Decoder decoder = new BASE64Decoder();\n            try {\n                b = decoder.decodeBuffer(s);\n                result = new String(b, \"utf-8\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }\n    public static void main(String args[]) {\n        Long startTime = System.currentTimeMillis();\n        String rawString = \"loveluoqi\";\n        String encodedString = encode(rawString);\n        String decodedString = decode(encodedString);\n        System.out.println(rawString);\n        System.out.println(encodedString);\n        System.out.println(decodedString);\n        Long endTime = System.currentTimeMillis();\n        System.out.println(\"总共耗时毫秒数：\" + (endTime - startTime));\n    }\n}\n```\n','<p>背景<br />\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样</p>\n<p>http://localhost:8080/resetpass?sid=c1b55b980db4eb74a4264a92d53cd953&amp;account=saysky</p>\n<p>验证原理就是，当用户点击链接，然后请求 控制器里的 resetpass 方法，获得 sid(密钥) 和 account(用户名) 两个参数。根据用户名去数据库中的 “邮件找回密码” 表(mail_retrieve)里寻找记录，获得 mailRetrieve 对象，然后比较 参数中的 sid 和 mailRetrieve.getSid() 即可，当然也可以加一个outtimes 超时时间 字段。</p>\n<p>如上链接，sid 是经过 MD5 加密，并且无需解密，只需要比较参数dis和数据库sid是否相等，而account 用户名一定要传过去，目前是直接明文显示，感觉不是特别好，所以这里需要给 accout 也加密一下比较好。然后在 控制器里接受参数的时候，然后在解密即可。</p>\n<p>目标是，无需太复杂，肉眼无法识别即可，但求效率高。</p>\n<p>BASE64 加密解码<br />\n代码如下</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.liuyanzhao.chuyun.util;\n<span class=\"hljs-keyword\">import</span> sun.misc.BASE64Decoder;\n<span class=\"hljs-keyword\">import</span> sun.misc.BASE64Encoder;\n<span class=\"hljs-keyword\">import</span> java.io.UnsupportedEncodingException;\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> 言曌\n * <span class=\"hljs-doctag\">@date</span> 2018/2/24 上午11:45\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Base64Util</span> </span>{\n    <span class=\"hljs-comment\">/**\n     * 加密\n     * <span class=\"hljs-doctag\">@param</span> str\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"restriction\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(String str)</span> </span>{\n        <span class=\"hljs-keyword\">byte</span>[] b = <span class=\"hljs-keyword\">null</span>;\n        String s = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            b = str.getBytes(<span class=\"hljs-string\">\"utf-8\"</span>);\n        } <span class=\"hljs-keyword\">catch</span> (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        <span class=\"hljs-keyword\">if</span> (b != <span class=\"hljs-keyword\">null</span>) {\n            s = <span class=\"hljs-keyword\">new</span> BASE64Encoder().encode(b);\n        }\n        <span class=\"hljs-keyword\">return</span> s;\n    }\n    <span class=\"hljs-comment\">/**\n     * 解密\n     * <span class=\"hljs-doctag\">@param</span> s\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"restriction\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String s)</span> </span>{\n        <span class=\"hljs-keyword\">byte</span>[] b = <span class=\"hljs-keyword\">null</span>;\n        String result = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span> (s != <span class=\"hljs-keyword\">null</span>) {\n            BASE64Decoder decoder = <span class=\"hljs-keyword\">new</span> BASE64Decoder();\n            <span class=\"hljs-keyword\">try</span> {\n                b = decoder.decodeBuffer(s);\n                result = <span class=\"hljs-keyword\">new</span> String(b, <span class=\"hljs-string\">\"utf-8\"</span>);\n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String args[])</span> </span>{\n        Long startTime = System.currentTimeMillis();\n        String rawString = <span class=\"hljs-string\">\"loveluoqi\"</span>;\n        String encodedString = encode(rawString);\n        String decodedString = decode(encodedString);\n        System.out.println(rawString);\n        System.out.println(encodedString);\n        System.out.println(decodedString);\n        Long endTime = System.currentTimeMillis();\n        System.out.println(<span class=\"hljs-string\">\"总共耗时毫秒数：\"</span> + (endTime - startTime));\n    }\n}\n</code></div></pre>\n','背景\n在给邮件发送 URL 链接找回密码时，会发送一个链接，像这样\nhttp://localhost','2019-08-20 00:40:24','2019-08-20 00:40:24',0,1001,2,0,0),(55,1,1,'Spring AOP实现事务管理','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性： ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070617154611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDM2MjQw,size_16,color_FFFFFF,t_70)\n以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。\n1.	Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：\n2.	\n|  隔离级别| 作用 |\n|--|--|\n| Isolation.READ_UNCOMMITTED |  读取未提交数据(会出现脏读, 不可重复读) |\n|Isolation.READ_COMMITTED |读取已提交数据(会出现不可重复读和幻读) |\n|Isolation.REPEATABLE_READ |可重复读(会出现幻读) |\n|Isolation.SERIALIZABLE |串行化 |\n3.	Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：\n\n|  传播行为| 作用 |\n|--|--|\n| Propagation.REQUIRED | 如果有事务,那么加入事务,没有的话新建一个(不写的情况下) |\n|  Propagation.NOT_SUPPORTED| 容器不为这个方法开启事务 |\n| Propagation.REQUIRES_NEW |  不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务|\n| Propagation.MANDATORY | 必须在一个已有的事务中执行,否则抛出异常 |\n| Propagation.NEVER |  必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)|\n|Propagation.SUPPORTS  | 如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务 |\n\n那么，在Spring中如何使用该事务注解呢？\n1.	在spring容器中配置如下配置信息：\n~~~xml\n<!-- 配置事务管理器(spring中的jdbc事务管理器) -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n	<!-- 注解方式配置事物，为了配合自定义注解 -->\n	<tx:annotation-driven transaction-manager=\"transactionManager\" /> \n~~~\n\n2.	在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706172438313.png)\n注意：<context:component-scan base-package=\"com.koi.service\" />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））\n二、	基于xml的配置：\n```xml\n<!-- 编写通知：对事务进行增强（通知），需要编写对切入点和具体执行事务的细节（隔离级别、传播行为等） -->\n	<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\" >\n		<tx:attributes>\n			<tx:method name=\"update*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"save*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"insert*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"add*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"delete*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n		</tx:attributes>\n	</tx:advice>\n	<!-- 编写aop,让spring自动对目标生成代理 -->\n	<aop:config>\n        <!-- 切入点 -->\n		<aop:pointcut expression=\"execution(* com.koi.service.impl.*.*(..))\"\n			id=\"myPointcut\" />\n		<!-- 配置通知器：将切入点与通知整合 -->\n		<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"myPointcut\" />\n	</aop:config>\n```\n','<p>事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。<br />\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。<br />\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了<br />\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性： <img src=\"https://img-blog.csdnimg.cn/2019070617154611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDM2MjQw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。</p>\n<ol>\n<li>Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：</li>\n<li></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Isolation.READ_UNCOMMITTED</td>\n<td>读取未提交数据(会出现脏读, 不可重复读)</td>\n</tr>\n<tr>\n<td>Isolation.READ_COMMITTED</td>\n<td>读取已提交数据(会出现不可重复读和幻读)</td>\n</tr>\n<tr>\n<td>Isolation.REPEATABLE_READ</td>\n<td>可重复读(会出现幻读)</td>\n</tr>\n<tr>\n<td>Isolation.SERIALIZABLE</td>\n<td>串行化</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>传播行为</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Propagation.REQUIRED</td>\n<td>如果有事务,那么加入事务,没有的话新建一个(不写的情况下)</td>\n</tr>\n<tr>\n<td>Propagation.NOT_SUPPORTED</td>\n<td>容器不为这个方法开启事务</td>\n</tr>\n<tr>\n<td>Propagation.REQUIRES_NEW</td>\n<td>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</td>\n</tr>\n<tr>\n<td>Propagation.MANDATORY</td>\n<td>必须在一个已有的事务中执行,否则抛出异常</td>\n</tr>\n<tr>\n<td>Propagation.NEVER</td>\n<td>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)</td>\n</tr>\n<tr>\n<td>Propagation.SUPPORTS</td>\n<td>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务</td>\n</tr>\n</tbody>\n</table>\n<p>那么，在Spring中如何使用该事务注解呢？</p>\n<ol>\n<li>在spring容器中配置如下配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 配置事务管理器(spring中的jdbc事务管理器) --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transactionManager\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"dataSource\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 注解方式配置事物，为了配合自定义注解 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:annotation-driven</span> <span class=\"hljs-attr\">transaction-manager</span>=<span class=\"hljs-string\">\"transactionManager\"</span> /&gt;</span> \n</code></div></pre>\n<ol start=\"2\">\n<li>在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public<br />\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。<br />\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED<br />\n<img src=\"https://img-blog.csdnimg.cn/20190706172438313.png\" alt=\"在这里插入图片描述\" /><br />\n注意：&lt;context:component-scan base-package=“com.koi.service” /&gt;<br />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））<br />\n二、	基于xml的配置：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 编写通知：对事务进行增强（通知），需要编写对切入点和具体执行事务的细节（隔离级别、传播行为等） --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:advice</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"txAdvice\"</span> <span class=\"hljs-attr\">transaction-manager</span>=<span class=\"hljs-string\">\"transactionManager\"</span> &gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:attributes</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"update*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"save*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"insert*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"add*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"delete*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tx:attributes</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tx:advice</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 编写aop,让spring自动对目标生成代理 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:config</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 切入点 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:pointcut</span> <span class=\"hljs-attr\">expression</span>=<span class=\"hljs-string\">\"execution(* com.koi.service.impl.*.*(..))\"</span>\n			<span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"myPointcut\"</span> /&gt;</span>\n		<span class=\"hljs-comment\">&lt;!-- 配置通知器：将切入点与通知整合 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:advisor</span> <span class=\"hljs-attr\">advice-ref</span>=<span class=\"hljs-string\">\"txAdvice\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"myPointcut\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:config</span>&gt;</span>\n</code></div></pre>\n','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务','2019-08-07 03:25:22','2019-08-07 03:25:22',0,56,2,0,0),(57,1,1,'66','56','<p>56</p>\n','56\n','2019-09-02 11:49:08','2019-09-02 11:49:08',0,26,2,0,1),(56,1,1,'ss','ss','<p>ss</p>\n','ss\n','2019-08-07 06:37:54','2019-08-07 06:37:54',0,485586,1,0,2),(58,1,1,'Spring AOP实现事务管理','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性： ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070617154611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDM2MjQw,size_16,color_FFFFFF,t_70)\n以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。\n1.	Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：\n2.	\n|  隔离级别| 作用 |\n|--|--|\n| Isolation.READ_UNCOMMITTED |  读取未提交数据(会出现脏读, 不可重复读) |\n|Isolation.READ_COMMITTED |读取已提交数据(会出现不可重复读和幻读) |\n|Isolation.REPEATABLE_READ |可重复读(会出现幻读) |\n|Isolation.SERIALIZABLE |串行化 |\n3.	Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：\n\n|  传播行为| 作用 |\n|--|--|\n| Propagation.REQUIRED | 如果有事务,那么加入事务,没有的话新建一个(不写的情况下) |\n|  Propagation.NOT_SUPPORTED| 容器不为这个方法开启事务 |\n| Propagation.REQUIRES_NEW |  不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务|\n| Propagation.MANDATORY | 必须在一个已有的事务中执行,否则抛出异常 |\n| Propagation.NEVER |  必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)|\n|Propagation.SUPPORTS  | 如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务 |\n\n那么，在Spring中如何使用该事务注解呢？\n1.	在spring容器中配置如下配置信息：\n~~~xml\n<!-- 配置事务管理器(spring中的jdbc事务管理器) -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n	<!-- 注解方式配置事物，为了配合自定义注解 -->\n	<tx:annotation-driven transaction-manager=\"transactionManager\" /> \n~~~\n\n2.	在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706172438313.png)\n注意：<context:component-scan base-package=\"com.koi.service\" />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））\n二、	基于xml的配置：\n```xml\n<!-- 编写通知：对事务进行增强（通知），需要编写对切入点和具体执行事务的细节（隔离级别、传播行为等） -->\n	<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\" >\n		<tx:attributes>\n			<tx:method name=\"update*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"save*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"insert*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"add*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n			<tx:method name=\"delete*\" rollback-for=\"CustomException\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" />\n		</tx:attributes>\n	</tx:advice>\n	<!-- 编写aop,让spring自动对目标生成代理 -->\n	<aop:config>\n        <!-- 切入点 -->\n		<aop:pointcut expression=\"execution(* com.koi.service.impl.*.*(..))\"\n			id=\"myPointcut\" />\n		<!-- 配置通知器：将切入点与通知整合 -->\n		<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"myPointcut\" />\n	</aop:config>\n```\n','<p>事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。<br />\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。<br />\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了<br />\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性： <img src=\"https://img-blog.csdnimg.cn/2019070617154611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDM2MjQw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。</p>\n<ol>\n<li>Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：</li>\n<li></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Isolation.READ_UNCOMMITTED</td>\n<td>读取未提交数据(会出现脏读, 不可重复读)</td>\n</tr>\n<tr>\n<td>Isolation.READ_COMMITTED</td>\n<td>读取已提交数据(会出现不可重复读和幻读)</td>\n</tr>\n<tr>\n<td>Isolation.REPEATABLE_READ</td>\n<td>可重复读(会出现幻读)</td>\n</tr>\n<tr>\n<td>Isolation.SERIALIZABLE</td>\n<td>串行化</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>传播行为</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Propagation.REQUIRED</td>\n<td>如果有事务,那么加入事务,没有的话新建一个(不写的情况下)</td>\n</tr>\n<tr>\n<td>Propagation.NOT_SUPPORTED</td>\n<td>容器不为这个方法开启事务</td>\n</tr>\n<tr>\n<td>Propagation.REQUIRES_NEW</td>\n<td>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</td>\n</tr>\n<tr>\n<td>Propagation.MANDATORY</td>\n<td>必须在一个已有的事务中执行,否则抛出异常</td>\n</tr>\n<tr>\n<td>Propagation.NEVER</td>\n<td>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)</td>\n</tr>\n<tr>\n<td>Propagation.SUPPORTS</td>\n<td>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务</td>\n</tr>\n</tbody>\n</table>\n<p>那么，在Spring中如何使用该事务注解呢？</p>\n<ol>\n<li>在spring容器中配置如下配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 配置事务管理器(spring中的jdbc事务管理器) --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transactionManager\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"dataSource\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 注解方式配置事物，为了配合自定义注解 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:annotation-driven</span> <span class=\"hljs-attr\">transaction-manager</span>=<span class=\"hljs-string\">\"transactionManager\"</span> /&gt;</span> \n</code></div></pre>\n<ol start=\"2\">\n<li>在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public<br />\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。<br />\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED<br />\n<img src=\"https://img-blog.csdnimg.cn/20190706172438313.png\" alt=\"在这里插入图片描述\" /><br />\n注意：&lt;context:component-scan base-package=“com.koi.service” /&gt;<br />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））<br />\n二、	基于xml的配置：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 编写通知：对事务进行增强（通知），需要编写对切入点和具体执行事务的细节（隔离级别、传播行为等） --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:advice</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"txAdvice\"</span> <span class=\"hljs-attr\">transaction-manager</span>=<span class=\"hljs-string\">\"transactionManager\"</span> &gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:attributes</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"update*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"save*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"insert*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"add*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"delete*\"</span> <span class=\"hljs-attr\">rollback-for</span>=<span class=\"hljs-string\">\"CustomException\"</span> <span class=\"hljs-attr\">isolation</span>=<span class=\"hljs-string\">\"DEFAULT\"</span> <span class=\"hljs-attr\">propagation</span>=<span class=\"hljs-string\">\"REQUIRED\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tx:attributes</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tx:advice</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 编写aop,让spring自动对目标生成代理 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:config</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 切入点 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:pointcut</span> <span class=\"hljs-attr\">expression</span>=<span class=\"hljs-string\">\"execution(* com.koi.service.impl.*.*(..))\"</span>\n			<span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"myPointcut\"</span> /&gt;</span>\n		<span class=\"hljs-comment\">&lt;!-- 配置通知器：将切入点与通知整合 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:advisor</span> <span class=\"hljs-attr\">advice-ref</span>=<span class=\"hljs-string\">\"txAdvice\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"myPointcut\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:config</span>&gt;</span>\n</code></div></pre>\n','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务','2019-08-16 02:36:47','2019-08-16 02:36:47',0,229,1,0,0),(59,1,1,'Spring与Redis整合',' 在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？\n 在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：\n\n> jedis-2.7.2.jar\n> spring-data-redis-1.6.0.RELEASE.jar\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619105112178.png)\n\n要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。\n1.	创建一个属性文件redis.properties，配置redis的相关参数：\n```\n# Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n```\n\n2.	创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）\n```java\npackage com.gx.common.utils;\nimport java.lang.reflect.Method;\npublic class KeyGenerator implements org.springframework.cache.interceptor.KeyGenerator {\n    @Override\n    public Object generate(Object o, Method method, Object... params) {\n        //规定  本类名+方法名+参数名 为key\n        StringBuilder sb = new StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(\"-\");\n        sb.append(method.getName());\n        sb.append(\"-\");\n        for (Object param : params) {\n            sb.append(param.toString());\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n3.	创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：\n \n\n```java\npackage com.gx.common.utils;\n\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\n\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private volatile JedisConnectionFactory jedisConnectionFactory;\n    private volatile RedisTemplate<String, String> redisTemplate;\n    private volatile RedisCacheManager redisCacheManager;\n\n    public RedisCacheConfig() {\n        super();\n    }\n\n    /**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * @param jedisConnectionFactory\n     * @param redisTemplate\n     * @param redisCacheManager\n     */\n    public RedisCacheConfig(JedisConnectionFactory jedisConnectionFactory, RedisTemplate<String, String> redisTemplate,\n                            RedisCacheManager redisCacheManager) {\n        this.jedisConnectionFactory = jedisConnectionFactory;\n        this.redisTemplate = redisTemplate;\n        this.redisCacheManager = redisCacheManager;\n    }\n\n    public JedisConnectionFactory getJedisConnecionFactory() {\n        return jedisConnectionFactory;\n    }\n\n    public RedisTemplate<String, String> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public RedisCacheManager getRedisCacheManager() {\n        return redisCacheManager;\n    }\n\n\n}\n```\n\n4.	创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：\n \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:cache=\"http://www.springframework.org/schema/cache\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\">\n	<!--配置redis的参数 -->\n	<bean class=\"redis.clients.jedis.JedisPoolConfig\" id=\"poolConfig\">\n		<property name=\"maxIdle\" value=\"${redis.maxIdle}\" />\n		<property name=\"maxTotal\" value=\"${redis.maxActive}\" />\n		<property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" />\n		<property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />\n	</bean>\n	<!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 -->\n	<bean id=\"jedisConnectionFactory\"\n		class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n		<property name=\"hostName\" value=\"${redis.host}\" />\n		<property name=\"port\" value=\"${redis.port}\" />\n		<!--<property name=\"password\" value=\"${redis.password}\"/> -->\n		<property name=\"database\" value=\"${redis.dbIndex}\" />\n		<property name=\"poolConfig\" ref=\"poolConfig\" />\n	</bean>\n	<!--redis操作模版,使用该对象可以操作redis -->\n	<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n		<property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n		<property name=\"keySerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" />\n		</property>\n		<property name=\"valueSerializer\">\n			<bean\n				class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" />\n		</property>\n		<!--开启事务 -->\n		<property name=\"enableTransactionSupport\" value=\"true\" />\n	</bean>\n	<!-- 配置redis缓存管理器 -->\n	<bean id=\"redisCacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\">\n		<constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" />\n		<property name=\"defaultExpiration\" value=\"${redis.expiration}\" />\n	</bean>\n	<!-- 配置RedisCacheConfig -->\n	<bean id=\"redisCacheConfig\" class=\"com.gx.common.utils.RedisCacheConfig\">\n		<constructor-arg ref=\"jedisConnectionFactory\" />\n		<constructor-arg ref=\"redisTemplate\" />\n		<constructor-arg ref=\"redisCacheManager\" />\n	</bean>\n	<!-- 声明redis中的key重新命名对象 -->\n	<bean id=\"keyGenerator\" class=\"com.gx.common.utils.KeyGenerator\" />\n	<cache:annotation-driven cache-manager=\"redisCacheManager\"\n		key-generator=\"keyGenerator\" />\n</beans>\n```\n\n5.	在applicationContext.xml中加载redis配置信息：\n \n\n```xml\n    <!-- 读取相关属性文件 -->\n	<context:property-placeholder location=\"classpath:db.properties,classpath:redis.properties\" />\n	<!-- 加载相应xml配置文件 -->\n	<import resource=\"spring-redis.xml\"/>\n```\n到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。\n \n```java\npackage com.gx.core.service.impl;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\nimport com.gx.core.dao.UserDao;\nimport com.gx.core.po.User;\nimport com.gx.core.service.UserService;\n@Service\npublic class UserServiceImpl implements UserService{\n	@Autowired\n	private UserDao userdao;\n	@Cacheable(\"user\")//添加缓存\n	public List<User> findUserById(String code) {\n	    System.out.println(\"查询数据库\");\n		return userdao.findUserById(code);\n	}\n	@CacheEvict(cacheNames=\"user\",allEntries=true)//清空缓存\n	public int addUser(User user) {\n		return userdao.addUser(user);\n	}\n}\n\n```\n@Cacheable、@CachePut、@CacheEvict 注释介绍：\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空\n','<p>在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方式有很多方面，从缓存方法入手，在项目中最为常见的一种方式。那么，缓存是个什么东西呢？在管理系统来看，缓存主要是对数据库查出来的数据进行保存到内存中，然后下次需要的时，直接从内存中获取出来，不需要再进行查询数据库的操作，从而节省从数据库查询数据的时间，达到优化性能效果。那么，该如何实现缓存呢？<br />\n在Spring中也提供了缓存的注解，但是主要是针对小型项目，如果在一些大型的项目中，该如何解决性能问题呢？现在主流的第三方缓存框架也有很多，都是针对一些大型项目的，其中包括Redis、Ehcache等缓存框架，下面主要针对Redis与Spring整合：<br />\n要使Spring与Redis框架整合，首先要下载相应的jar包和Redis服务端，其中与Spring整合的主要jar包和Redis的客户端、服务端如下：</p>\n<blockquote>\n<p>jedis-2.7.2.jar<br />\nspring-data-redis-1.6.0.RELEASE.jar<br />\n<img src=\"https://img-blog.csdnimg.cn/20190619105112178.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>要在项目中使用Redis必须启动Redis服务器（redis-server.exe），要不然使用不了，因为Redis本质就是一个非关系的数据库（Key-Value，键值对存储）。</p>\n<ol>\n<li>创建一个属性文件redis.properties，配置redis的相关参数：</li>\n</ol>\n<pre><code class=\"lang-\"># Redis settings\n#服务器ip地址\nredis.host=127.0.0.1\n#端口号\nredis.port=6379\n#服务器索引\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\nredis.maxActive=600\n#超时等待时间\nredis.maxWait=1000\nredis.testOnBorrow=true\n</code></pre>\n<ol start=\"2\">\n<li>创建KeyGenerator类，实现org.springframework.cache.interceptor.KeyGenerator接口，定义Redis中key的命名方式（类名+方法名+参数名）</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n<span class=\"hljs-keyword\">import</span> java.lang.reflect.Method;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">KeyGenerator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">springframework</span>.<span class=\"hljs-title\">cache</span>.<span class=\"hljs-title\">interceptor</span>.<span class=\"hljs-title\">KeyGenerator</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(Object o, Method method, Object... params)</span> </span>{\n        <span class=\"hljs-comment\">//规定  本类名+方法名+参数名 为key</span>\n        StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n        sb.append(o.getClass().getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        sb.append(method.getName());\n        sb.append(<span class=\"hljs-string\">\"-\"</span>);\n        <span class=\"hljs-keyword\">for</span> (Object param : params) {\n            sb.append(param.toString());\n        }\n        <span class=\"hljs-keyword\">return</span> sb.toString();\n    }\n}\n\n</code></div></pre>\n<ol start=\"3\">\n<li>创建RedisCacheConfig类，继承CachingConfigurerSupport类，自定义一些配置参数，代码如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.common.utils;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.cache.RedisCacheManager;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedisCacheConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CachingConfigurerSupport</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> JedisConnectionFactory jedisConnectionFactory;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisTemplate&lt;String, String&gt; redisTemplate;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> RedisCacheManager redisCacheManager;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 带参数的构造方法 初始化所有的成员变量\n     *\n     * <span class=\"hljs-doctag\">@param</span> jedisConnectionFactory\n     * <span class=\"hljs-doctag\">@param</span> redisTemplate\n     * <span class=\"hljs-doctag\">@param</span> redisCacheManager\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RedisCacheConfig</span><span class=\"hljs-params\">(JedisConnectionFactory jedisConnectionFactory, RedisTemplate&lt;String, String&gt; redisTemplate,\n                            RedisCacheManager redisCacheManager)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.jedisConnectionFactory = jedisConnectionFactory;\n        <span class=\"hljs-keyword\">this</span>.redisTemplate = redisTemplate;\n        <span class=\"hljs-keyword\">this</span>.redisCacheManager = redisCacheManager;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> JedisConnectionFactory <span class=\"hljs-title\">getJedisConnecionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> jedisConnectionFactory;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisTemplate&lt;String, String&gt; <span class=\"hljs-title\">getRedisTemplate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisTemplate;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RedisCacheManager <span class=\"hljs-title\">getRedisCacheManager</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> redisCacheManager;\n    }\n\n\n}\n</code></div></pre>\n<ol start=\"4\">\n<li>创建spring-redis.xml文件，配置redis参数和声明一些相关的对象，配置信息如下：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n	<span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"hljs-attr\">xmlns:context</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/context\"</span>\n	<span class=\"hljs-attr\">xmlns:cache</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/cache\"</span>\n	<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans \n	http://www.springframework.org/schema/beans/spring-beans-4.3.xsd \n	http://www.springframework.org/schema/context \n	http://www.springframework.org/schema/context/spring-context-4.3.xsd \n	http://www.springframework.org/schema/cache\n	http://www.springframework.org/schema/cache/spring-cache-4.3.xsd\"</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的参数 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"redis.clients.jedis.JedisPoolConfig\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"poolConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxIdle\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxIdle}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxTotal\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxActive}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"maxWaitMillis\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.maxWait}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"testOnBorrow\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.testOnBorrow}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--配置redis的连接参数 如需要密码,请配置,database是redis的指定哪个库 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hostName\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.host}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"port\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.port}\"</span> /&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--&lt;property name=\"password\" value=\"${redis.password}\"/&gt; --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"database\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.dbIndex}\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"poolConfig\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"poolConfig\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--redis操作模版,使用该对象可以操作redis --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.core.StringRedisTemplate\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"connectionFactory\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"keySerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.StringRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"valueSerializer\"</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span>\n				<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n		<span class=\"hljs-comment\">&lt;!--开启事务 --&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"enableTransactionSupport\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置redis缓存管理器 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.data.redis.cache.RedisCacheManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"redisOperations\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"defaultExpiration\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"${redis.expiration}\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 配置RedisCacheConfig --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"redisCacheConfig\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.RedisCacheConfig\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"jedisConnectionFactory\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisTemplate\"</span> /&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constructor-arg</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 声明redis中的key重新命名对象 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.gx.common.utils.KeyGenerator\"</span> /&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cache:annotation-driven</span> <span class=\"hljs-attr\">cache-manager</span>=<span class=\"hljs-string\">\"redisCacheManager\"</span>\n		<span class=\"hljs-attr\">key-generator</span>=<span class=\"hljs-string\">\"keyGenerator\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></div></pre>\n<ol start=\"5\">\n<li>在applicationContext.xml中加载redis配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">    <span class=\"hljs-comment\">&lt;!-- 读取相关属性文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context:property-placeholder</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">\"classpath:db.properties,classpath:redis.properties\"</span> /&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 加载相应xml配置文件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">import</span> <span class=\"hljs-attr\">resource</span>=<span class=\"hljs-string\">\"spring-redis.xml\"</span>/&gt;</span>\n</code></div></pre>\n<p>到目前为止，Spring与Redis整合成功了。那么，该如何使用缓存呢？一般要使用缓存，都是在service层来进行使用，下面代码是对redis与Spring整合成功的用法：<br />\n缓存流程说明：在调用findUserById()方法前，首先判断在redis中是否有该缓存(通过key的命名com.gx.core.service.impl.UserServiceImpl-findUserById-1703)来查询，如果没有该缓存，就执行findUserById()方法，反之，直接从缓存中获取，不再执行findUserById()方法。为了保证数据的准确性和不出现脏读，在新增、修改、删除时，根据一定的条件把相应的缓存清空。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.gx.core.service.impl;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.CacheEvict;\n<span class=\"hljs-keyword\">import</span> org.springframework.cache.annotation.Cacheable;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;\n<span class=\"hljs-keyword\">import</span> com.gx.core.dao.UserDao;\n<span class=\"hljs-keyword\">import</span> com.gx.core.po.User;\n<span class=\"hljs-keyword\">import</span> com.gx.core.service.UserService;\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span></span>{\n	<span class=\"hljs-meta\">@Autowired</span>\n	<span class=\"hljs-keyword\">private</span> UserDao userdao;\n	<span class=\"hljs-meta\">@Cacheable</span>(<span class=\"hljs-string\">\"user\"</span>)<span class=\"hljs-comment\">//添加缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;User&gt; <span class=\"hljs-title\">findUserById</span><span class=\"hljs-params\">(String code)</span> </span>{\n	    System.out.println(<span class=\"hljs-string\">\"查询数据库\"</span>);\n		<span class=\"hljs-keyword\">return</span> userdao.findUserById(code);\n	}\n	<span class=\"hljs-meta\">@CacheEvict</span>(cacheNames=<span class=\"hljs-string\">\"user\"</span>,allEntries=<span class=\"hljs-keyword\">true</span>)<span class=\"hljs-comment\">//清空缓存</span>\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">addUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n		<span class=\"hljs-keyword\">return</span> userdao.addUser(user);\n	}\n}\n\n</code></div></pre>\n<p>@Cacheable、@CachePut、@CacheEvict 注释介绍：<br />\n@Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存<br />\n@CachePut 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用<br />\n@CachEvict 主要针对方法配置，能够根据一定的条件对缓存进行清空</p>\n','在实际项目开发中，随着项目的需求或者用户访问量的增大，这时不得不考虑项目性能问题。其中，优化性能的方','2019-09-02 11:20:33','2019-09-02 11:20:33',0,5454414,2,0,0),(52,23,1,'AOP实现事务管理','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性： \n\n![75156.jpg](http://localhost:8082/blogImg/20190731/99c6326c-d4f8-4f31-bf3d-7fa40c0b1383_75156.jpg)\n\n以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。\n1.	Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：\n2.	\n|  隔离级别| 作用 |\n|--|--|\n| Isolation.READ_UNCOMMITTED |  读取未提交数据(会出现脏读, 不可重复读) |\n|Isolation.READ_COMMITTED |读取已提交数据(会出现不可重复读和幻读) |\n|Isolation.REPEATABLE_READ |可重复读(会出现幻读) |\n|Isolation.SERIALIZABLE |串行化 |\n3.	Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：\n\n|  传播行为| 作用 |\n|--|--|\n| Propagation.REQUIRED | 如果有事务,那么加入事务,没有的话新建一个(不写的情况下) |\n|  Propagation.NOT_SUPPORTED| 容器不为这个方法开启事务 |\n| Propagation.REQUIRES_NEW |  不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务|\n| Propagation.MANDATORY | 必须在一个已有的事务中执行,否则抛出异常 |\n| Propagation.NEVER |  必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)|\n|Propagation.SUPPORTS  | 如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务 |\n\n那么，在Spring中如何使用该事务注解呢？\n1.	在spring容器中配置如下配置信息：\n~~~xml\n<!-- 配置事务管理器(spring中的jdbc事务管理器) -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n	<!-- 注解方式配置事物，为了配合自定义注解 -->\n	<tx:annotation-driven transaction-manager=\"transactionManager\" /> \n~~~\n\n2.	在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706172438313.png)\n注意：<context:component-scan base-package=\"com.koi.service\" />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））\n二、	基于xml的配置：\n```java\n @RequestMapping(value = \"/allBlog\", method = RequestMethod.GET)\n    public Map<String, Object> getArticleByState(@RequestParam(value = \"state\") Integer state, @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"count\", defaultValue = \"6\") Integer count, String keywords) {\n        int totalCount = articleService.getArticleCountByState(state, keywords);\n        int start = (page - 1) * count;\n        List<Article> articles = articleService.getArticleByState(state, keywords, start, count);\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"totalCount\", totalCount);\n        map.put(\"articles\", articles);\n        return map;\n    }\n```\n','<p>事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务管理，其实就是对数据库的事务进行管理（提交、回滚）。<br />\n在Spring框架中最常用的就是声明式配置事务，而声明式配置可以基于xml进行配置，也可以基于注解进行配置。<br />\n一、	基于注解的配置，顾名思义，既然基于注解来配置，就必不可少注解，Spring框架中提供了<br />\n@Transactional注解，该注解主要是配置在需要开启事务的service接口的实现类中，其中@Transactional值有以下属性：</p>\n<p><img src=\"http://localhost:8082/blogImg/20190731/99c6326c-d4f8-4f31-bf3d-7fa40c0b1383_75156.jpg\" alt=\"75156.jpg\" /></p>\n<p>以上属性主要针对isolation和propagation来讲，这两个属性的值都是枚举。</p>\n<ol>\n<li>Isolation(事务隔离级别)该属性的作用是表事务隔离开，对于一些多并发的访问或者更新同一个数据库时，必须要设置该属性，要不然会出现脏读，更新丢失等问题。而isolation属性就很有效的解决该问题，其中isolation属性提供了不同隔离级别的枚举值：</li>\n<li></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Isolation.READ_UNCOMMITTED</td>\n<td>读取未提交数据(会出现脏读, 不可重复读)</td>\n</tr>\n<tr>\n<td>Isolation.READ_COMMITTED</td>\n<td>读取已提交数据(会出现不可重复读和幻读)</td>\n</tr>\n<tr>\n<td>Isolation.REPEATABLE_READ</td>\n<td>可重复读(会出现幻读)</td>\n</tr>\n<tr>\n<td>Isolation.SERIALIZABLE</td>\n<td>串行化</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>Propagation(事务传播行为)该属性的作用是该如何创建事务，怎样加入事务：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>传播行为</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Propagation.REQUIRED</td>\n<td>如果有事务,那么加入事务,没有的话新建一个(不写的情况下)</td>\n</tr>\n<tr>\n<td>Propagation.NOT_SUPPORTED</td>\n<td>容器不为这个方法开启事务</td>\n</tr>\n<tr>\n<td>Propagation.REQUIRES_NEW</td>\n<td>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务</td>\n</tr>\n<tr>\n<td>Propagation.MANDATORY</td>\n<td>必须在一个已有的事务中执行,否则抛出异常</td>\n</tr>\n<tr>\n<td>Propagation.NEVER</td>\n<td>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)</td>\n</tr>\n<tr>\n<td>Propagation.SUPPORTS</td>\n<td>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务</td>\n</tr>\n</tbody>\n</table>\n<p>那么，在Spring中如何使用该事务注解呢？</p>\n<ol>\n<li>在spring容器中配置如下配置信息：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 配置事务管理器(spring中的jdbc事务管理器) --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transactionManager\"</span>\n		<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dataSource\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"dataSource\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!-- 注解方式配置事物，为了配合自定义注解 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tx:annotation-driven</span> <span class=\"hljs-attr\">transaction-manager</span>=<span class=\"hljs-string\">\"transactionManager\"</span> /&gt;</span> \n</code></div></pre>\n<ol start=\"2\">\n<li>在service的接口实现类中添加@Teansactional注解，注意：实现类或者实现方法访问权限为public<br />\n在@Transactional注解中设置isolation（事务隔离级别）和propagation(事务传播行为)这两个属性，这两个属性根据业务需求来设置。其中rollbackFor该属性的作用是：当程序报Exception该异常时，事务执行回滚操作，保证数据的准确性。<br />\n如果某个方法不需要开启事务，就在该方法上提交注解，propagation设置为Propagation.NOT_SUPPORTED<br />\n<img src=\"https://img-blog.csdnimg.cn/20190706172438313.png\" alt=\"在这里插入图片描述\" /><br />\n注意：&lt;context:component-scan base-package=“com.koi.service” /&gt;<br />\n该注解必须放置spring（启动容器）该容器中，要不然事务会启动失败（因为扫描器会扫描所有的bean（事务注解@Transactional））<br />\n二、	基于xml的配置：</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"> <span class=\"hljs-meta\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/allBlog\"</span>, method = RequestMethod.GET)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Map&lt;String, Object&gt; <span class=\"hljs-title\">getArticleByState</span><span class=\"hljs-params\">(@RequestParam(value = <span class=\"hljs-string\">\"state\"</span>)</span> Integer state, @<span class=\"hljs-title\">RequestParam</span><span class=\"hljs-params\">(value = <span class=\"hljs-string\">\"page\"</span>, defaultValue = <span class=\"hljs-string\">\"1\"</span>)</span> Integer page, @<span class=\"hljs-title\">RequestParam</span><span class=\"hljs-params\">(value = <span class=\"hljs-string\">\"count\"</span>, defaultValue = <span class=\"hljs-string\">\"6\"</span>)</span> Integer count, String keywords) </span>{\n        <span class=\"hljs-keyword\">int</span> totalCount = articleService.getArticleCountByState(state, keywords);\n        <span class=\"hljs-keyword\">int</span> start = (page - <span class=\"hljs-number\">1</span>) * count;\n        List&lt;Article&gt; articles = articleService.getArticleByState(state, keywords, start, count);\n        Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n        map.put(<span class=\"hljs-string\">\"totalCount\"</span>, totalCount);\n        map.put(<span class=\"hljs-string\">\"articles\"</span>, articles);\n        <span class=\"hljs-keyword\">return</span> map;\n    }\n</code></div></pre>\n','事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。Sping中的事务','2019-08-06 09:05:07','2019-08-06 09:05:07',0,27,2,0,0),(68,38,1,'SS','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-02 11:54:58','2019-09-02 11:54:58',0,0,0,0,0),(69,23,1,'发布','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:17:14','2019-09-03 11:17:14',0,0,0,0,0),(70,23,1,'52','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:17:28','2019-09-03 11:17:28',0,0,0,0,1),(71,23,1,'dasdas','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:17:47','2019-09-03 11:17:47',0,1,1,0,0),(72,23,1,'dsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:18:00','2019-09-03 11:18:00',0,0,0,0,0),(73,23,1,'dsadsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:18:17','2019-09-03 11:18:17',0,0,0,0,0),(74,1,1,'dsadsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:18:32','2019-09-03 11:18:32',0,0,0,0,1),(75,23,1,'6666','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:18:45','2019-09-03 11:18:45',0,0,0,0,0),(76,23,1,'3636','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:18:58','2019-09-03 11:18:58',0,0,0,0,0),(77,23,1,'6666dsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:19:14','2019-09-03 11:19:14',0,1,1,0,0),(78,1,1,'555','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:19:44','2019-09-03 11:19:44',0,1,1,0,0),(79,34,1,'dsaff','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:20:10','2019-09-03 11:20:10',0,0,0,0,0),(80,34,1,'dasdsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:20:25','2019-09-03 11:20:25',0,0,0,0,0),(81,34,1,'555','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:20:38','2019-09-03 11:20:38',0,0,0,0,0),(82,34,1,'dsaads','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:20:53','2019-09-03 11:20:53',0,0,0,0,0),(83,34,1,'dasdaas','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:21:10','2019-09-03 11:21:10',0,0,0,0,0),(84,34,1,'222','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:21:30','2019-09-03 11:21:30',0,0,0,0,1),(85,34,1,'dsadsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:21:55','2019-09-03 11:21:55',0,0,0,0,2),(86,34,1,'eeee','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:22:06','2019-09-03 11:22:06',0,1,1,0,1),(87,38,1,'565','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:22:21','2019-09-03 11:22:21',0,0,0,0,0),(88,38,1,'565','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:24:29','2019-09-03 11:24:29',0,1,0,0,0),(89,38,1,'dsads','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:24:22','2019-09-03 11:24:22',0,0,0,0,0),(90,38,1,'233','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:24:13','2019-09-03 11:24:13',0,1,0,0,1),(91,38,1,'dsadsa','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:24:06','2019-09-03 11:24:06',0,1,1,0,0),(92,38,1,'666','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:23:58','2019-09-03 11:23:58',0,0,0,0,0),(93,38,1,'3333','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:24:49','2019-09-03 11:24:49',0,1,1,0,0),(94,38,1,'66662244','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？ \n1.	首先，在vue项目中使用以下命令来安装axios。\n> npm install axios\n2.	一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817210517136.png)\n3.	在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：\n首先，在api.js文件中用import axios from \'axios\'引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：\n\n**Get请求：**\n \n\n```javascript\nimport axios from \'axios\'\nlet  base= \'/api\';\nexport const getRequest = (url,params) => {\n  return axios({\n    method: \'get\',\n    data:params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    },\n    url: `${base}${url}`\n  });\n}\n```\n\n**Post请求：**\n \n\n```javascript\nexport const postRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      // Do whatever you want to transform the data\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Put请求：**\n \n\n```javascript\nexport const putRequest = (url, params) => {\n  return axios({\n    method: \'put\',\n    url: `${base}${url}`,\n    data: params,\n    transformRequest: [function (data) {\n      let ret = \'\'\n      for (let it in data) {\n        ret += encodeURIComponent(it) + \'=\' + encodeURIComponent(data[it]) + \'&\'\n      }\n      return ret\n    }],\n    headers: {\n      \'Content-Type\': \'application/x-www-form-urlencoded\'\n    }\n  });\n}\n```\n\n**Delete请求：**\n \n```javascript\nexport const deleteRequest = (url) => {\n  return axios({\n    method: \'delete\',\n    url: `${base}${url}`\n  });\n}\n```\n\n**上传文件请求：**\n\n```javascript\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: \'post\',\n    url: `${base}${url}`,\n    data: params,\n    headers: {\n      \'Content-Type\': \'multipart/form-data\'\n    }\n  });\n}\n```\n','<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json等。所以我们在vue项目中请求后台获取数据一般都是用axios,但是直接操作axios会比较繁琐，所有一般会封装好axios使用。那么该如何使用封装好axios呢？</p>\n<ol>\n<li>首先，在vue项目中使用以下命令来安装axios。</li>\n</ol>\n<blockquote>\n<p>npm install axios</p>\n</blockquote>\n<ol start=\"2\">\n<li>一般我会在项目的src目录中，新建一个utils文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190817210517136.png\" alt=\"在这里插入图片描述\" /></li>\n<li>在api.js中封装axios，一般会封装get,post，put,delete和上传文件几种提交方式：<br />\n首先，在api.js文件中用import axios from \'axios’引用axios，我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。声明一个常量的base前缀可以设置axios的默认请求地址，代码如下：</li>\n</ol>\n<p><strong>Get请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">let</span>  base= <span class=\"hljs-string\">\'/api\'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url,params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'get\'</span>,\n    <span class=\"hljs-attr\">data</span>:params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    },\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>Post请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> postRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-comment\">// Do whatever you want to transform the data</span>\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Put请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> putRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'put\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">transformRequest</span>: [<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-string\">\'\'</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> it <span class=\"hljs-keyword\">in</span> data) {\n        ret += <span class=\"hljs-built_in\">encodeURIComponent</span>(it) + <span class=\"hljs-string\">\'=\'</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[it]) + <span class=\"hljs-string\">\'&amp;\'</span>\n      }\n      <span class=\"hljs-keyword\">return</span> ret\n    }],\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'application/x-www-form-urlencoded\'</span>\n    }\n  });\n}\n</code></div></pre>\n<p><strong>Delete请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> deleteRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'delete\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>\n  });\n}\n</code></div></pre>\n<p><strong>上传文件请求：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> uploadFileRequest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, params</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> axios({\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\'post\'</span>,\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${base}</span><span class=\"hljs-subst\">${url}</span>`</span>,\n    <span class=\"hljs-attr\">data</span>: params,\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">\'Content-Type\'</span>: <span class=\"hljs-string\">\'multipart/form-data\'</span>\n    }\n  });\n}\n</code></div></pre>\n','在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的htt','2019-09-03 11:25:05','2019-09-03 11:25:05',0,1,1,0,0);

/*Table structure for table `article_tag` */

DROP TABLE IF EXISTS `article_tag`;

CREATE TABLE `article_tag` (
  `a_id` int(11) DEFAULT NULL,
  `t_id` int(11) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `article_tag` */

insert  into `article_tag`(`a_id`,`t_id`) values (1,6),(1,3),(5,1),(5,7),(33,1),(30,8),(29,9),(23,10),(52,2),(52,40),(52,72),(59,72),(61,2),(61,73),(65,74),(65,72),(65,71),(65,38),(65,42),(66,75),(67,71),(67,42);

/*Table structure for table `category` */

DROP TABLE IF EXISTS `category`;

CREATE TABLE `category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(30) DEFAULT NULL,
  `createdate` datetime DEFAULT NULL,
  PRIMARY KEY (`category_id`)
) ENGINE=MyISAM AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;

/*Data for the table `category` */

insert  into `category`(`category_id`,`category_name`,`createdate`) values (1,'编程开发','2019-08-22 02:24:02'),(23,'程序人生','2019-08-22 02:32:33'),(38,'其他','2019-08-22 02:37:29'),(34,'工具教程','2019-08-22 02:35:59'),(37,'数据库','2019-08-22 02:37:26');

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `comment_id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`comment_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `comment` */

/*Table structure for table `link` */

DROP TABLE IF EXISTS `link`;

CREATE TABLE `link` (
  `link_id` int(11) NOT NULL AUTO_INCREMENT,
  `link_name` varchar(255) NOT NULL,
  `link_url` varchar(255) NOT NULL,
  `link_avatar` varchar(255) DEFAULT NULL,
  `link_describe` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`link_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `link` */

/*Table structure for table `log` */

DROP TABLE IF EXISTS `log`;

CREATE TABLE `log` (
  `log_id` int(11) NOT NULL AUTO_INCREMENT,
  `log_operateor` varchar(50) DEFAULT NULL,
  `log_operateType` varchar(50) DEFAULT NULL,
  `log_operateDate` datetime DEFAULT NULL,
  `log_operateResule` varchar(50) DEFAULT NULL,
  `log_ip` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`log_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `log` */

/*Table structure for table `permission` */

DROP TABLE IF EXISTS `permission`;

CREATE TABLE `permission` (
  `permission_id` int(11) NOT NULL AUTO_INCREMENT,
  `permission_name` varchar(50) NOT NULL,
  `permission_url` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`permission_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `permission` */

/*Table structure for table `role` */

DROP TABLE IF EXISTS `role`;

CREATE TABLE `role` (
  `role_id` int(11) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(30) NOT NULL,
  `role_description` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`role_id`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

/*Data for the table `role` */

insert  into `role`(`role_id`,`role_name`,`role_description`) values (1,'超级管理员',NULL),(2,'普通用户',NULL);

/*Table structure for table `role_permission` */

DROP TABLE IF EXISTS `role_permission`;

CREATE TABLE `role_permission` (
  `r_id` int(11) DEFAULT NULL,
  `p_id` int(11) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `role_permission` */

/*Table structure for table `slide` */

DROP TABLE IF EXISTS `slide`;

CREATE TABLE `slide` (
  `slide_id` int(11) NOT NULL AUTO_INCREMENT,
  `slide_title` varchar(255) NOT NULL,
  `slide_url` varchar(255) NOT NULL,
  `slide_picture` varchar(255) NOT NULL,
  `slide_sort` int(11) DEFAULT NULL,
  `slide_target` varchar(255) DEFAULT NULL,
  `slide_type` int(11) DEFAULT NULL,
  PRIMARY KEY (`slide_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `slide` */

/*Table structure for table `tag` */

DROP TABLE IF EXISTS `tag`;

CREATE TABLE `tag` (
  `tag_id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) NOT NULL,
  PRIMARY KEY (`tag_id`)
) ENGINE=MyISAM AUTO_INCREMENT=76 DEFAULT CHARSET=utf8;

/*Data for the table `tag` */

insert  into `tag`(`tag_id`,`tag_name`) values (1,'aop'),(2,'java'),(51,'MySQL'),(50,'JSP'),(49,'Servlet'),(47,'IDEA'),(46,'JavaScript'),(45,'SpringBoot'),(44,'Mybatis'),(43,'SpringMVC'),(42,'Spring'),(41,'Maven'),(40,'搜索引擎'),(24,'JSON'),(30,'Shiro'),(38,'redis'),(39,'数据库'),(52,'CSS'),(53,'HTML'),(54,'缓存'),(55,'POJO'),(56,'Jquery'),(57,'MyEclipe'),(59,'Vue'),(60,'API'),(61,'Echarts'),(62,'Session'),(63,'Oracle'),(64,'重定向'),(65,'转发'),(66,'定时任务'),(67,'Layui'),(68,'Freemarker'),(69,'算法'),(70,'数据结构'),(71,'spring'),(72,'框架整合'),(73,'Java'),(74,'Redis'),(75,'axios');

/*Table structure for table `thirdbind` */

DROP TABLE IF EXISTS `thirdbind`;

CREATE TABLE `thirdbind` (
  `thirdbind_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `thirdbind_key` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`thirdbind_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `thirdbind` */

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL,
  `user_pass` varchar(255) NOT NULL,
  `user_nickname` varchar(255) DEFAULT NULL,
  `user_email` varchar(100) NOT NULL,
  `user_avatar` varchar(100) DEFAULT NULL,
  `user_registerTime` datetime DEFAULT NULL,
  `user_lastTime` datetime DEFAULT NULL,
  `user_lastIp` varchar(255) DEFAULT NULL,
  `user_status` int(11) DEFAULT NULL,
  `user_salt` varchar(255) DEFAULT NULL,
  `user_sex` int(11) DEFAULT NULL,
  `user_comment` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`user_id`,`user_name`,`user_pass`,`user_nickname`,`user_email`,`user_avatar`,`user_registerTime`,`user_lastTime`,`user_lastIp`,`user_status`,`user_salt`,`user_sex`,`user_comment`) values (1,'koi','41b875f1de024bf8f47d7de0f1e7554f','锦鲤','973319261@qq.com','http://localhost:8082/blogImg/Avatar/75a26799-7fa3-4dcc-a329-9b6331eb4d31_QQ图片20191113183650.png','2019-07-31 07:10:06','2020-01-10 08:46:41','127.0.0.1',0,'6b2c0444fce9be0392a863e40e553999',0,'备注');

/*Table structure for table `user_role` */

DROP TABLE IF EXISTS `user_role`;

CREATE TABLE `user_role` (
  `u_id` int(11) DEFAULT NULL,
  `r_id` int(11) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

/*Data for the table `user_role` */

insert  into `user_role`(`u_id`,`r_id`) values (1,1);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
